# 注解

## Spring中的注解

### 1.给容器中注入组件

（1）包扫描+组件标注注解

- @Component：把普通pojo实例化到spring容器中。将其实例化为bean对象。

  > @Controller、@Service、@Repository都可以称为@Component。
  >
  > @Controller：控制层
  >
  > @Service：业务层
  >
  > @Repository：数据访问层

- @Bean：注解一个方法，这个方法的返回值一般是一个对象，@Bean就会将这个返回的对象进行实例化为一个bean对象，并且将这个对象注入到Spring容器中。

**@Component和@Bean两个注解的区别：**

​	@Component主要于普通的类，@Bean主要用于配置类中的方法。一个是基于类的注解，一个是基于方法的注解。

### 2、注入bean的注解

- @Autowired：由bean提供@Autowired可以作用在变量、setter方法、构造函数上；有个属性为required，可以配置为false；
- @Resource：由JSR-250提供，@Autowired、@Inject是默认按照类型匹配的，@Resource默认是按照名称匹配的，但是也能按照类型进行匹配。
- @Inject：由JSR-330提供，@Inject用法和@Autowired一样。
- @Primary：让spring进行自动装配的时候，默认使用首选的bean，和@Qualifier一个效果。
- @Qualifier：如果容器中有一个以上匹配的Bean，则可以通过@Qualifier注解限定Bean的名称

注意：

> @Autowired注解**默认按照类型装配**，如果容器中包含多个同一类型的Bean，那么启动容器时会报找不到指定类型bean的异常，解决办法是结合**@Qualifier**注解进行限定，指定注入的bean名称。
>
> @Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。

### 3、Java配置类相关注解

- @Configuration：声明当前类为配置类。
- @Bean：注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式。
- @ComponentScan：指示Spring Boot扫描当前包及其子包中的所有@Component、@Service、@Repository和@Controller注解的类，并将它们注册为Spring Bean。也可以指定扫描的范围。默认范围为当前包及其子包。


### 4、切面（AOP）相关注解

Spring支持AspectJ的注解式切面编程。

- @Aspect：声明一个切面

- @After：在方法执行之后执行（方法上）

- @Before：在方法执行之前执行（方法上）

- @Around：在方法执行之前与之后执行（方法上）

- @PointCut：声明切点

- @EnableAspectJAutoProxy：在java配置类中使用注解开启Spring对AspectJ代理的支持

### 5、@Bean

​	@Bean的实例：

```java
@Configuration
public class DataBaseConfig {
    @Bean("dataSource")   //设置Bean的名称
    public DataSource getDataSource(){
        DataSource dataSource = new DataSource();
        dataSource.setUserId("jingsi");
        dataSource.setPassword("123456");
        dataSource.setUrl("www");
        return dataSource; //返回值为一个对象
    }
}
```

#### **@Bean的属性**

> - value：bean别名和name是相互依赖关联的，value,name如果都使用的话值必须要一致；
> - name：bean名称，如果不写会默认为注解的方法名称；
> - autowire：自定装配默认是不开启的，建议尽量不要开启，因为自动装配不能装配基本数据类型、字符串、数组等，这是自动装配设计的局限性，并且自动装配不如依赖注入精确；
> - initMethod：bean的初始化之前的执行方法.
> - destroyMethod：默认使用javaConfig配置的bean，如果存在close或者shutdown方法，则在bean销毁时会自动执行该方法，如果你不想执行该方法，则添加@Bean(destroyMethod="")来防止出发销毁方法；

```java
public class MyBean {
    public MyBean(){
        System.out.println("MyBean Initializing");
    }
    public void init(){
        System.out.println("Bean 初始化方法被调用");
    }
    public void destroy(){
        System.out.println("Bean 销毁方法被调用");
    }
}
@Configuration
public class AppConfig {
    @Bean(initMethod = "init", destroyMethod = "destroy")
    public MyBean myBean(){
        return new MyBean();
    }
}
```

#### **@Bean与其它注解的联合使用**

**@Scope**

​	设置类型包括：设置Spring容器如何新建Bean实例（方法上，得有@Bean）

> - ① Singleton（单例,一个Spring容器中只有一个bean实例，默认模式）,
>
> - ② Protetype（每次调用新建一个bean）,
>
> - ③ Request（web项目中，给每个http request新建一个bean）,
>
> - ④ Session（web项目中，给每个http session新建一个bean）,
>
> - ⑤ GlobalSession（给每一个 global http session新建一个Bean实例）
>

**@DependsOn** 

​	指当前bean所依赖的bean。

```java
@Configuration
public class AppConfigWithDependsOn {
    @Bean("firstBean")
    @DependsOn(value = {
            "secondBean",
            "thirdBean"
    })
    public FirstBean firstBean() {
        return new FirstBean();
    }
    @Bean("secondBean")
    public SecondBean secondBean() {
        return new SecondBean();
    }
    @Bean("thirdBean")
    public ThirdBean thirdBean() {
        return new ThirdBean();
    }
}
创建Bean的顺序为：
SecondBean Initialized via Constuctor
ThirdBean Initialized via Constuctor
FirstBean Initialized via Constuctor
```

因为FirstBean的创建依赖SecondBean和ThirdBean的创建，所以要先创建SecondBean和ThirdBean再创建自己。

**@Lazy**

​	表明一个bean 是否延迟加载，可以作用在方法上，表示这个方法被延迟加载；可以作用在@Component (或者由@Component 作为原注解) 注释的类上，表明这个类中所有的bean 都被延迟加载。当给一个Bean加上了这个注解，那么这个Bean的创建就会延迟，不会急切的创建。

**@Primary**

​	意思是在众多相同的bean中，优先使用用@Primary注解的bean。

### 6、@Value

（1）支持如下方式的注入：

- 注入普通字符

- 注入操作系统属性
- 注入表达式结果
- 注入其它bean属性
- 注入文件资源
- 注入网站资源
- 注入配置文件

（2）@Value三种情况的用法。

- “${}”是去找外部配置的参数，将值赋过来
- “#{}”是SpEL表达式，去寻找对应变量的内容，通常来获取bean的属性，或者调用bean的某个方法。

例如：

普通属性

```java
@Repository
public class ConnectionPool {
    @Value("jdbc:mysql://localhost:3306/test")
    private String url;
    @Value("com.mysql.jdbc.Driver")
    private String driveName;
    @Value("Scott")
    private String userName;
    @Value("10")
    private int no;
}
```

使用"${}"

```java
//在application.properties文件中添加以下
jdbc.driverClass=com.mysql
jdbc.url=3306@local
jdbc.user=admin
jdbc.pwd=pwd

@Component
public class ValueDemo {
    @Value("${jdbc.driverClass}")
    private String driver;

    @PostConstruct
    public void run(){
        System.out.println(driver);
    }
}
输出为：com.mysql
```

上例中就是将application.properties配置文件中的jdbc.driverClass的值赋值给了driver。

使用"#{}"，可以获取其它Bean类中的属性，和一个表达式，返回这个表达式的结果。

```java
//其他bean，自定义名称为 myBeans
@Component("myBeans")
public class OtherBean {
    @Value("OtherBean的NAME属性")
    private String name; 
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
public class ValueController {
    @Value("#{myBeans.name}")
    private String fromAnotherBean; 
    @Test
    public  void  getValue(){ 
        System.out.println(fromAnotherBean);
    }
}
输出为:OtherBean的NAME属性
```

```java
public class ValueController {
    // 生成一个随机数
    @Value("#{ T(java.lang.Math).random() * 1000.0 }")
    private double randomNumber;
    public void getValue(){
        System.out.println(randomNumber);
    }
}
输出为：一个随机数
```

### 7、测试相关注解

@RunWith：运行器，Spring中通常用于对JUnit的支持，主要用来指定使用那个工具进行测试

> @RunWith(JUnit4.class)就是指用JUnit4来运行
>
> @RunWith(SpringJUnit4ClassRunner.class),让测试运行于Spring测试环境
>
> @RunWith(Suite.class)的话就是一套测试集合，

@ContextConfiguration：用来加载配置配置文件，其中classes属性用来加载配置类。@ContextConfiguration这个注解通常与@RunWith(SpringJUnit4ClassRunner.class)联合使用用来测试

> 当我们想要在某个测试类使用`@Autowired`注解来引入收集起来的bean时，只需要给这个测试类添加`@ContextConfiguration`注解来标注我们想要导入这个测试类的某些bean。

```java
@Configuration
@ComponentScan
public class CDPlayConfig {

}
```

此时如果想要测试的话，就可以这么写：

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=CDPlayConfig.class) //就可以上面类里的Bean引用进行进行测试
public class CDPlayerTest {

}
```

### 8、异步相关

@EnableAsync：配置类中通过此注解开启对异步任务的支持，使用这个注解后才能使用异步方法

@Async：在实际执行的bean方法使用该注解来声明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）

使用注意：

> - 调用异步方法类上或启动类加上注解 @EnableAsync
> - 在需要被异步调用的方法外加上 @Async
> - 所使用的 @Async 注解方法的类对象应该是Spring容器管理的bean对象；

### 9、事务注解

​	@Transactional

​	@EnableTransactionManagement

## SpringMVC中的注解

### 1、@Controller

​	@Controller用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。当浏览器发送的请求最后将会通过这个@Controller类进行处理。

### 2、@RequestMapping

　　RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。

RequestMapping注解有六个属性:

> value：指定请求的实际地址。
>
> method： 指定请求的method类型， GET、POST、PUT、DELETE等。
>
> consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html。
>
> produces:    指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。
>
> params： 指定request中必须包含某些参数值是，才让该方法处理。
>
> headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。

这个方法还能将请求方法和请求路径进行结合

@GetMapping：处理get方式请求的映射

@PostMapping：处理post方式请求的映射

@PutMapping：处理put方式请求的映射

@DeleteMapping：处理delete方式请求的映射

### 3、@ResponseBody　

　　作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用。一般需要把返回的数据作为JSON格式时使用最多。配合前端AJAX请求。

​	在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。

```java
@Controller
@ResponseBody
public class text {
    @RequestMapping("/text")
    public String t(){
        return "login";
    }
}
```

上例中加上了@ResponseBody就是将返回的login字符串变为json对象交给浏览器，然后浏览器进行解析在页面上展示，如果没有加上@ResponseBody就会进行页面的跳转，就会寻找login.html进行跳转（这种跳转方式基本不用）。

### 4、@RestController

​	该注解结合了@Controller和@ResponseBody，具有两者的功能。可以直接写在类上，使整个类都具备这个功能。可以使用这个注解为这个类取一个别名，防止在进行spring容器加载中有类名相同而导致冲突。

```java
@RestController("USERShopCpntroller")
```



### 5、@RequestBody

​	@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；而最常用的使用请求体传参的无疑是POST请求了，所以使用@RequestBody接收数据时，一般都用POST方式进行提交。==在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。==

```java
@RequestMapping("/demo3")
@ResponseBody
public String demo3(@RequestBody User user){
    System.out.println(user);
    return "good";
}
输出为：User(name=林云龙, age=15)
```

使用@RequestBody进行接收前端发送的user对象的数据。

前端发送的请求为：使用post方法在请求体中发送JSON格式的数据。

![](img_@\Snipaste_2023-10-13_16-56-33.png)

### 6、@RequestParam

> 不加@RequestParam前端的参数名需要和后端控制器的变量名保持一致才能生效。
>
> 不加@RequestParam参数为非必传，加@RequestParam写法参数为必传。但@RequestParam可以通过@RequestParam(required = false)设置为非必传。
>
> @RequestParam可以通过@RequestParam(“userId”)或者@RequestParam(value = “userId”)指定传入的参数名。（最主要的作用）还能用来接收集合、数组
>
> @RequestParam可以通过@RequestParam(defaultValue = “0”)指定参数默认值。

```java
    //设置当前访问的路径
    @RequestMapping("/demo1")
    //设置返回值类型
    @ResponseBody
    //@RequestParam将请求参数中的name赋给username
    public String demo1(@RequestParam("name") String username, int age){
        System.out.println( username + age );
        return username + age ;
    }
输出为：lin18
```

前端发送的请求为：

==http://localhost:8080/demo1?name=lin&age=18==

其中参数username使用了@RequestParam注解，所以在前端请求中使用了name进行替代。而age没有使用这个注解，所以参数名必须保持一致。

> Get方式请求，参数放在url中时：
>
> 不加@RequestParam注解：url可带参数也可不带参数，输入 localhost:8080/list1 以及 localhost:8080/list1?userId=xxx 方法都能执行
> 加@RequestParam注解：url必须带有参数。也就是说你直接输入localhost:8080/list2 会报错，不会执行方法。只能输入localhost:8080/list2?userId=xxx 才能执行相应的方法

注意：

- get和post方式将参数放入Params中都能进行访问,如果是post请求的话,将参数放入form_data中和放入x-www-formdate-urlencoded中后端都能接收到。
- @RequestParam在一个接口方法参数中可以使用多个。
- 不能接收Post请求中在请求体中的json格式数据。

### 7、@PathVariable

​	@PathVariable是用来获得请求url中的动态参数的，带占位符的URL是 Spring3.0 新增的功能，URL中的 {xxx} 占位符可以通过 @PathVariable(“xxx”) 绑定到操作方法的入参中。

```java
@RequestMapping("/user/{id}")
public String testPathVariable(@PathVariable("id") String id){
    System.out.println("路径上的占位符的值="+id);
    return "success";
}
结果为：路径上的占位符的值=15
```

前端的请求为：==http://localhost:8080/user/15==

发送请求后URL中的15就和参数中的id相互绑定上了。这样就可以获取请求URL中的参数，比如要通过用户的id进行用户查询时，可以使用。

### 8、@WebFilter

​	@WebFilter 用于将一个类声明为过滤器，该注解将会在部署时被容器处理，容器将根据具体的属性配置将相应的类部署为过滤器。该注解具有下表给出的一些常用属性 ( 以下所有属性均为可选属性，但是 value、urlPatterns、servletNames 三者必需至少包含一个，且 value 和 urlPatterns 不能共存，如果同时指定，通常忽略 value 的取值 )

例如：==@WebFilter(filterName = "loginCheckFilter",urlPatterns = "/*")== 这个过滤器的名称为：loginCheckFIlter，然后过滤的路径为：urlPatterns。

使用这个注解的类需要实现一个Filter接口。



### 8、@SessionAttributes



### 9、@ModelAttribute

### 10、@CookieValue

### 11、@ControllerAdvice

### 12、@ExceptionHandler







## SpringBoot中的注解

### **1、@SpringBootApplication**：

作为SpringBoot项目的启动类的注解，用来启动项目。

​	这个注解就是集成了：==@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan==这三个注解。其中@SpringBootConfiguration：表示这个类为配置类；@EnableAutoConfiguration：表示开启自动置，我们平时所说springboot无配置就是这个参数起的作用，他读取了springboot默认的配置；@ComponentScan：表示自动扫描，这个扫描默认只能扫同一级的目录。

### 2、@SpringBootTest

作为SpringBoot项目测试类的注解。

SpringBootTest默认集成了以下功能：

- JUnit 5: Java单元测试框架
- Spring Test & Spring Boot Test: Spring Boot的测试工具和支持
- AssertJ: 流式断言
- Hamcrest: Hamcrest断言
- Mockito: Java Mock框架
- JSONassert: JSON断言
- JsonPath: XPath for JSON



## Mybatis中的注解

### 1、@Mapper和@MapperScan

​	@Mapper注解，目的就是为了不再写mapper映射文件，使开发更加的简单。

​	一般将这个注解添加到接口上，经过编译以后就会生成这个接口的实现类。但是在如果在每个接口上都加上这个注解会比较麻烦，就可以使用@MapperScan注解。这个注解可以将所有的接口放在一个包下，那么这个包下的所有接口都将会被实现为类。例如@MapperScan(com.example.dao),那么在包com.example.dao包里的全部接口都将生成对应的实现类。书写的位置一般在SpringBoot的启动类上。

​	两个的区别：@Mapper书写在一个接口上，@MapperScan书写在启动类上。

@Mapper和@Repository的区别：

- @Mapper是Mybatis自带的一个注解。不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中。
- @Repository是Spring提供的一个注解。使用后，需要在启动类上加@MapperScan(***)来表明Mapper类的位置，否则扫描不到

### 2、增删改查

| 注解    | 说明     |
| ------- | -------- |
| @Insert | 实现新增 |
| @Delete | 实现删除 |
| @Update | 实现更新 |
| @Select | 实现查询 |

```java
/**
 * 在mybatis中针对CRUD一共有四个注解
 * @Select @Insert @Update @Delete
 */
public interface IUserDao {

    /**
     * 查询所有用户
     * @return
     */
    @Select("select * from user")
    List<User> findAll();

    /**
     * 保存用户
     * @param user
     */
    @Insert("insert into user(username,address,sex,birthday)values(#{username},#{address},#{sex},#{birthday})")
    void saveUser(User user);

    /**
     * 更新用户
     * @param user
     */
    @Update("update user set username=#{username},sex=#{sex},birthday=#{birthday},address=#{address} where id=#{id}")
    void updateUser(User user);

    /**
     * 删除用户
     * @param userId
     */
    @Delete("delete from user where id=#{id}")
    void deleteUser(Integer userId);

    /**
     * 根据id查询用户
     * @param userId
     * @return
     */
    @Select("select * from user where id=#{id}")
    User findById(Integer userId);
    
    /**
     * 根据用户名称模糊查询
     * @param username
     * @return
     */
    //@Select("select * from user where username like #{username}") //占位符
    @Select("select * from user where username like '%${value}%'")  //字符串拼接
    List<User> findByName(String username);

    /**
     * 查询总数量
     * @return
     */
    @Select("select count(*) from user")
    int findTotal();
}
```

### 3、结果有关

#### **@Results和@Result**

​	当数据库字段名与实体类对应的属性名不一致时，可以使用@Results映射来将其对应起来。column为数据库字段名，porperty为实体类属性名，jdbcType为数据库字段数据类型，id为是否为主键。

```java
@Select({"select id, name, class_id from my_student"})
@Results({
    @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true),
    @Result(column="name", property="name", jdbcType=JdbcType.VARCHAR),
    @Result(column="class_id", property="classId", jdbcType=JdbcType.INTEGER)
})
List<Student> selectAll();
```

#### **@ResultMap**

​	当这段@Results代码需要在多个方法用到时，为了提高代码复用性，我们可以为这个@Results注解设置id，然后使用@ResultMap注解来复用这段代码。

```java
@Select({"select id, name, class_id from my_student"})
@Results(id="studentMap", value={
    @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true),
    @Result(column="class_id", property="classId", jdbcType=JdbcType.INTEGER)
})
List<Student> selectAll();

@Select({"select id, name, class_id from my_student where id = #{id}"})
@ResultMap(value="studentMap")
Student selectById(integer id);
```

#### **@One**



#### **@Many**



## MybatisPlus中的注解

### 1、@Tablename

​	注解用来将指定的数据库表和javaBean进行映射。多用于项目实体类中。还能在配置文件中进行配置本项目中所有的表的前缀：==table-prefix: T==。表示本项目中所有的表的前缀为T。

```java
@Tablename("user")
public class User {
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
```

### 2、@TableId

​	注解一般用来指定javaBean中和数据库中主键相对应的属性。

​	写法为：@TableId(value=“数据库主键字段”,type = IdType.六种类型之一)

​	idType有以下六种：

|       值       |                             描述                             |
| :------------: | :----------------------------------------------------------: |
|    AUTO(0)     |                          数据库自增                          |
|    INPUT(2)    |                           自行输入                           |
|    NONE(1)     |                      无状态（默认类型）                      |
|  ASSIGN_ID(3)  |    分配ID (主键类型为number或string)，默认策略为雪花算法     |
| ASSIGN_UUID(4) | 分配UUID (主键类型为 string)，默认实现类(UUID.replace(“-”,“”)) |

其中还有ID_WORKER(3),ID_WORKER_STR(3),UUID(4);已经被弃用。还能在项目的配置文件中进行全局设置，

==id-type: ASSIGN_ID==

### 3、@TableFiled

- 主要用来解决实体类的字段名与数据库中的字段名不匹配的问题（数据库user_addr，字段useraddr未驼峰）

- 实体类中的属性字段在表中不存在的问题

- 表示自动填充字段一般用于字段名

  注解中的属性：

  1.FieldFill

  | 值            | 描述                 |
  | ------------- | -------------------- |
  | DEFAULT       | 默认不处理           |
  | INSERT        | 插入时填充字段       |
  | UPDATE        | 更新时填充字段       |
  | INSERT_UPDATE | 插入和更新时填充字段 |


### 4、@TableLogic

​	表字段逻辑处理注解（逻辑删除）。可以应用在数据恢复中。当加上这个注解后，所有的查询操作都会将这个条件加入到查询条件中去。

逻辑删除和物理删除的区别：
	物理删除：在数据库表中将这条数据完全删除，以后的查询看不到这条数据。

​	逻辑删除：在数据库表中设置一个删除的标志位。执行逻辑删除后，将这个标注为变为已经删除的状态，比如设置一个字段为delete，这个字段为0表示没删除，为1表示已经删除。但是这是一种假删除，在数据库中仍然可以看到这条数据。

这个注解有两个属性，用来设置逻辑上表示已经删除和没有删除对应的值：

| 属性   | 类型   | 必须指定 | 默认值 | 描述         |
| ------ | ------ | -------- | ------ | ------------ |
| value  | String | 否       | ""     | 逻辑未删除值 |
| delval | String | 否       | ""     | 逻辑删除值   |

### 5、@EnumValue

​	通用枚举的注解，用来在标记枚举类中要使用的字段，并且这个字段的类型要和数据库中的类型一样，否则会报错。









## JSON中的注解





## 其它注解

### 1、@Slf4j

@Slf4j是Lombok框架中的一个注解，用于在Java类中自动生成日志记录器。主要用于简化日志记录。

@Slf4j注解非常简单，只需要在Java类中添加这个注解即可。在使用时，我们可以直接使用log变量来记录日志，而不需要再引入其他的日志框架.

```java
@Slf4j
public class MyService {
    public void doSomething() {
        log.debug("This is a debug message.");
        log.info("This is an info message.");
        log.error("This is an error message.");
    }
}
在这个例子中，我们定义了一个MyService类，并使用@Slf4j注解来自动生成日志记录器。然后，在doSomething()方法中，我们直接使用log变量来记录日志，而不需要再引入其他的日志框架。
```



### 2、简化Pojo类

@Data：用于自动生成JavaBean的getters、setters、toString、hashCode和equals方法。

@NoArgsConstructor：用于自动生成一个无参构造方法。

@AllArgsConstructor：用于生成全参构造函数。

@EqualsAndHashCode：用于生成hashCode和equals方法。

@ToString：用于生成toString方法。

上面这些注解都是Lombok框架中的注解，主要用来简化Pojo实体类的生成。

